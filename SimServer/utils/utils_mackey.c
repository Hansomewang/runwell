/*
 * keycodec.c
 */
#include <stdio.h>
#include <string.h>
 
#ifndef linux

#include <windows.h>

#else		// linux
#include <unistd.h>
#include <sys/types.h>

typedef unsigned long long ULONGLONG;
typedef unsigned char			 BYTE;
typedef unsigned short		 WORD;
typedef char *						 LPSTR;
typedef const char *		   LPCTSTR;


#endif

//////////////////////////////////////////////////////////////////////////////////////////////
//  Encoding/Decoding functions																
//																						
// <<< IMPORTANT >>>																	
//   This function is found not working correctly when compiled in VC with speed optimization	//
//   It is recommended to turn off any optimization when use this function in your code.	//
//////////////////////////////////////////////////////////////////////////////////////////////
//
// ifaddr2sn -- convert 6 byte MAC address to 4 short so that it could be presented like
//        xxxx-xxxx-xxxx-xxxx (each 'x' is a digit)
void ifaddr2sn( BYTE *ifaddr, WORD *sn )
{
	ULONGLONG	u64sn;
	BYTE		hwaddr[6];
	int			i;

	memcpy( hwaddr, ifaddr, 6 );
	for ( i=0; i<6; i+=2 )
		hwaddr[i] ^= 0xff;
	memcpy( &u64sn, hwaddr, 6 );
	sn[2] = (WORD)(u64sn & 0xfff);
	sn[3] = (WORD)(((u64sn & 0xfff000) >> 12) & 0xfff);
	sn[0] = (WORD)(((u64sn & 0xfff000000LL) >> 24) & 0xfff);
	sn[1] = (WORD)(((u64sn & 0xfff000000000LL) >> 36) & 0xfff);
}

// reversed function to convert four short to 6 byte MAC address
void sn2ifaddr( WORD *sn, BYTE *ifaddr )
{
	ULONGLONG	u64sn;
	BYTE		hwaddr[6];
	int			i;

	u64sn = sn[1];
	u64sn <<= 12;
	u64sn |= sn[0];
	u64sn <<= 12;
	u64sn |= sn[3];
	u64sn <<= 12;
	u64sn |= sn[2];
	memcpy( hwaddr, &u64sn, 6 );
	for (i=0; i<6; i+= 2 )
		hwaddr[i] ^= 0xff;
	memcpy( ifaddr, hwaddr, 6 );
}
///////////////////////////////////////////////////////////////////////////////////////////
// convert 5 bits value to '0' ~ '9', 'A'-'X' but skip 'I' and 'O' which is easy to be confused with 1 and 0 in print and hand writing.
static int radix5( char code )
{
	if ( code < 10 )
		return code + '0';
	else if ( 10 <= code && code <= 17 )
		return (code - 10) + 'A';
	else if ( 18 <= code && code <= 22 )
		return  code - 18 + 'J';
	else if ( 23 <= code && code <= 31 )
		return code - 23 + 'P';
	return 'Z';		// unknown cannot be this
}

// inverse of radix5
static int radix5_r( char ch )
{
	if ( '0' <= ch && ch <= '9' )
		return ch - '0';
	else if ( 'A' <= ch && ch <= 'H' )
		return ch - 'A' + 10;
	else if ( 'J' <= ch && ch <= 'N' )
		return ch - 'J' + 18;
	else if ( 'P' <= ch && ch <= 'X' )
		return ch - 'P' + 23;
	return -1;
}

// Convert encrypted MAC code (10 bytes) to activation key string (16 character)
// id: 10 bytes MAC code generated by 
//	  GetMACCode --> EncodeMACCode
// key: 16 bytes key (reversable converted from id)
//
void id2key( const BYTE *id, LPSTR key )
{
	WORD	value[5];
	int	odd;
	int	i, j;

	memset( key, 0, 16 );
	if ( (odd=(*id % 2)) != 0 )
	{
		value[0] = ((short)id[1]) * 256 + id[3];
		value[1] = ((short)id[5]) * 256 + id[7];
		value[2] = ((short)id[9]) * 256 + id[0];
		value[3] = ((short)id[2]) * 256 + id[4];
		value[4] = ((short)id[6]) * 256 + id[8];
	}
	else
	{
		value[0] = ((short)id[0]) * 256 + id[2];
		value[1] = ((short)id[4]) * 256 + id[6];
		value[2] = ((short)id[8]) * 256 + id[1];
		value[3] = ((short)id[3]) * 256 + id[5];
		value[4] = ((short)id[7]) * 256 + id[9];
	}
	for (i=0, j=0; i<15; i+=3, j++)
	{
		key[i] = value[j] & 0x1f;
		key[i+1] = (value[j] & 0x3e0) >> 5;
		key[i+2] = (value[j] & 0x7c00) >> 10;
	}
	for(i=0, j=0; i<15; i++)
	{
		j += key[i];
		key[i] = radix5(key[i]);
	}
	key[15] = j % 13 + odd * 13;
	key[15] = radix5( key[15] );
	key[16] = '\0';
}

// revered function of id2key. That is used to convert the activation key string to MAC encripted code
int key2id( const BYTE *key_in, LPSTR id )
{
	WORD	value[5];
	char	key[20];
	int		i, j;
	int		odd;

	memset( id, 0, 10 );
	memcpy( key, key_in, 16 );
	for(i=0, j=0; i<15; i++)
	{
		key[i] = radix5_r( key[i] );
		j += key[i];
	}
	key[15] = radix5_r( key[15] );
	if ( key[15] > 12 )
	{
		odd = 1;
		key[15] -= 13;
	}
	else
		odd = 0;
	j = j % 13;
	if ( j != key[15] ) return -1;

	for( i=0, j=0; i<15; i+=3, j++)
	{
		value[j] = key[i+2];
		value[j] <<= 5;
		value[j] |= key[i+1];
		value[j] <<= 5;
		value[j] |= key[i];
	}

	if ( odd )
	{
		id[1] = value[0] / 256; id[3] = value[0] % 256;
		id[5] = value[1] / 256; id[7] = value[1] % 256;
		id[9] = value[2] / 256; id[0] = value[2] % 256;
		id[2] = value[3] / 256; id[4] = value[3] % 256;
		id[6] = value[4] / 256; id[8] = value[4] % 256;
	}
	else
	{
		id[0] = value[0] / 256; id[2] = value[0] % 256;
		id[4] = value[1] / 256; id[6] = value[1] % 256;
		id[8] = value[2] / 256; id[1] = value[2] % 256;
		id[3] = value[3] / 256; id[5] = value[3] % 256;
		id[7] = value[4] / 256; id[9] = value[4] % 256;
	}
	id[10] = '\0';
	return 0;
}

// put '-' between every group of 4 chracter. Make it more readable
LPCTSTR dashed_key( LPSTR key )
{
	static char dash_key[ 32 ];

	memcpy( dash_key, key, 4 );
	dash_key[4] = '-';
	memcpy( dash_key+5, key+4, 4 );
	dash_key[9] = '-';
	memcpy( dash_key+10, key+8, 4 );
	dash_key[14] = '-';
	memcpy( dash_key+15, key+12, 4 );
	dash_key[19] = '\0';
	return dash_key;
}
//////////////////////////////////////////////////////////////////////////////////////
static void btoh( BYTE byte, BYTE *ptr )
{
	ptr[0] = (byte >> 4) & 0x0f;
	if ( ptr[0] < 10 )
		ptr[0] += '0';
	else
		ptr[0] = (ptr[0] - 10) + 'A';
	ptr[1] = byte & 0x0f;
	if ( ptr[1] < 10 )
		ptr[1] += '0';
	else
		ptr[1] = (ptr[1] - 10) + 'A';
}

// scrumble 6 bytes MAC address to 10 bytes HEX value
// MACAddr: 6 bytes MAC address
// MACCode: 10 bytes scrumbled hex code
void GetMACCode( BYTE *ifaddr, BYTE *MACCode, int nType )
{
	BYTE	*ptr;
	BYTE	b[5], byte;
	int	i;

	ptr = ifaddr;
	if ( nType == 0 )				/* permanent activiation code */
	{
		b[0] = ptr[0] ^ ptr[1];
		b[1] = ptr[2] ^ ptr[3];
		b[2] = ptr[4] ^ ptr[5];
		b[3] = 0xff;
		b[4] = 0;
		for (i=0; i<6; i++)
		{
			if ( ptr[i] < b[3] )  b[3] = ptr[i];
			if ( ptr[i] > b[4] )  b[4] = ptr[i];
		}
		b[3] = b[3] ^ 0xff;
		b[4] = b[4] ^ 0xff;
		for( i=0; i<5; i++ )
		{
			byte = b[i];
			b[i] = ((byte & 0xf0) >> 4) | ((byte & 0x0f) << 4);
		}
	}
	else if ( nType == 1 )			/* trai activiation code */
	{
		b[0] = ptr[0] ^ ptr[3];
		b[1] = ptr[1] ^ ptr[4];
		b[2] = ptr[2] ^ ptr[5];
		b[3] = 0xff;
		b[4] = 0;
		for (i=0; i<6; i++)
		{
			if ( ptr[i] < b[3] )  b[3] = ptr[i];
			if ( ptr[i] > b[4] )  b[4] = ptr[i];
		}
		b[3] = b[3] ^ 0xff;
		b[4] = b[4] ^ 0xff;
	}
	
	for( i=0; i<5; i++, MACCode+=2 )
	{
	    btoh( b[i], MACCode );
	}
}

// Encode the scrumbled 10 bytes MAC code further
void EncodeMACCode( BYTE *code )
{
	int	i;
	BYTE c;
	
	for( i=0; i<10; i++ )
	{
		c = code[ i ];

		if( c>='0' && c<='9' ) {
			c -= '0';
		} else if ( c>='A' && c<='F' ) {
			c -= 'A';
			c += 0xA;
		} else {
			c = 16 + i%6;
			/* 16 -- 21 */
		}
		c += (i*13)%7;
		c += 'A';
		code[i] = c;
	}
}

